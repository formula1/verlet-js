Collision Algorithm

substep = smallestarea/(largestvelocity/Math.convertToSecond(substep));
polygons.sort(function(a,b){
 a.aabb.min.x - b.aabb.min.x
})

while(step > 0){
  substep = Math.min(substep,step);
  var l = polygon.length
  var ll;
  var dirty = false;
  var minstep = substep;
  var u = l;
  while(l--){
    ll = l-1;
    while(ll--){
      if(polygon[l].max.x < polygon[ll].min.x) break;
      intersection = polygon[l].timeOfIntersection(polygon[ll],minstep);
      if(intersection){
        u = l+1
        dirty = intersection;
        minstep = intersection.time;
      }
    }
  }
  l = polygon.length;
  for(u;u < l;u++){
    polygon[u].applyVelocities(minstep);
  }
  if(minstep < substep){
    dirty.distributeVelocities();
  }
  step -= minstep;
}


Polygon.test(l)
 -l.test(ll)


Things that may speed things up
Binary search for aabbx.max[] with this.min.x
-iterate on aabbx.min[] until aabb.xmin > this.max.x
--while iterating, skip where this.min.y > other.max.y and this.max.y < other.min.y

Though I would have to figure out if polygon[a] and polygon[b] have already been handled
-that could be handled by

I can also check when they are sorted if this index if this.min == the index of this.max
-This would mean there is nothing in between and thus nothing to search for

var l = AABB.length

while(l--){
  if(AABB.minX_Index[l] == AABB.maxX_Index[l]) continue;
  flagx = true
  if(AABB.minY_Index[l] == AABB.maxY_Index[l]){
    if(flagx){

    }
    continue;
  }


}


Helping Constraints
-Constraints will recognize what other constraints have done and...
-- add what it needs for the timestamp
-- or find the balance between its own needs and the others

Transformation equation
-Why would I want this?
--This is good for going backwards in time?
---I could also just store a copy point... and then run the copy...
